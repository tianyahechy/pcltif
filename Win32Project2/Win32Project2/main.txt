1,自定义一个CLOUD，能够正确写文件和读文件，OK
2,三角化，OK
3，把PCL的东西移植过来，看看行不行，能不能正常调通。
4,移植过来，OK，
5,将新的移植过来，看看能否输出TIF文件。（没有设置地理坐标系）,100个点没问题
6，发现指定点没有在三角形内，这个步骤循环很长，因为要遍历所有的三角形。
是不是循环太多了。果然，先提取出来三角面集合，而不是每次都要再循环中去创造它。整合后OK
7,10000个点试一下。还是感觉慢了一点
8，调整一下GEOTRANSFORM，设为100个试试,OK
	dGeotransform[0] = topLeftX;   //左上坐标X
	dGeotransform[1] = xResolution;	//横向分辨率
	dGeotransform[2] = rotationX;	//旋转角度
	dGeotransform[3] = topLeftY;	//左上坐标Y
	dGeotransform[4] = rotationY;	//旋转角度
	dGeotransform[5] = yRosultion * (-1.0);	//y分辨率（负值）
9，值改为float,跑个10000坐标的试下, 发现有问题
10，存储格式改为GDT_BYTE,表示可能还有问题
11，用pdataset->rasterIO,试试看
memset(pBuf, theValue, sizeof(float) * iWidth);可能有问题，因为把一行值都赋了一个值.用memcpy逐行测试，不连续
12，设定X,Y间距均为1米，则改下输出格式，1000个点，竟然超过255，但是显示出来的是最多255，成了0和255两个值了
13，
14，归一化。感觉一片灰白的
15，减去255，求灰度值剩下的东西，OK

16，可以把(minz,maxZ）归一化。到（0,255）中，但是没有连续感了。
17，还是原来的归一化方法，OK
18，用所有的点时间慢，先试试5000点
19,创建文件时，改为GDT_FLOAT32.以能输出相应的大小灰度值。
20,用release,并去掉归一化，不输出每步。
21,投影时，左上角为MINX,MAXY。像素分辨率和图像大小混淆了，像素分辨率应为1，重整代码，图像大小对了，但是中间图像有突变。

23，对前25个点，基本上都是1.3左右的，查一下
24，对相邻两点相差太大的。（39,24,11.4）和（40,24，-3）,只找这两个点各自所在的三角形，从中查出这两个三角形的三个顶点坐标
查到了，发现是三边不均匀的缘故，三个点，有的两点距离远，有的距离近。
其中，有个是三个顶点的Y值基本相同。
25,20000个点，有两个点差距很大（175,58，24.6），（176,58，-0.121429）（201,50,19.685715），（200,50，-3.15）（188,57,23.829166），（187,57，-3.253846）（188,54,17.113043）（189,54，-2.99）（222,47,24.23218）（221,47，-2.108333）
发现一个点在多个三角形内。

26，拷贝判断点是否在三角形内的段代码过来。ok
27,正常输出至屏幕
28，输出文本格式
29,用delauny三角化，凸包，发现三角形很近了。OK
30，输出新文件,OK，但是有洞为0，查询下（118,70）的像素为0
31，在射线与线段是否相交
	bool bHasIntersectionPoint = computeIntersectionPointBetweenSegAndRay(segAB, rayCP, interSectionPoint);
	if (!bHasIntersectionPoint)
	{
		//std::cout << "没有交点" << std::endl;
		bIntersect = false;
		return bIntersect;
	}

发现原来还有特殊情况，在三个顶点上，已加上，该点已无误，

32，在点云中提取处该点，也是无误，OK
33，生成点云，20000个点看上去没问题。
34，拆分两个文件common.h和quadcompute.h，加入了分块。计算耗时时长，从输出后的时间减去启动的当前时间即为耗时,1136秒，将近20分钟进行2万个点。
35，加上quadNetWork类,OK,
36,加上QUADNETWORK类，并输出，10*10用了163秒，2分半，速度快了7倍。
37，加上各段时间,ok
2万点,读取点云61秒,三角化0秒,查找各三角形高度21秒,其余为0,共82秒
4万点,读取点云60秒,三角化1秒,查找各三角形高度107秒,其余不计,共168秒
8万点,读取点云61秒,三角化1秒,查找三角形高度为747秒,共809秒


三角化时的索引,用来得到三角形的Z值，而不是查找。ok

38,调用PCLTif类,用以替代以前的QuadNetWork类, OK
39,将像素分辨率和minx,miny放入类里,ok
40,将细节抽取出来,设置细节,将getPCLData放入成员函数中
41,读入点云文件名,将点云数据集合放入成员变量中
42,将三角化后的三角形集合当作成员变量
43,基本上差不多了,输入参数只剩下点云名称和像素分辨率了.
44,对于一幅图像来说应该调用到最简单了,输入,处理一个函数,即可.其余参数均需返回值即可.
45,求两图差,并输出,OK
46,先读入图的一行，并内存传递，OK,
47，直接用vector行不行.OK
48,以45为基础，改改aftuil中的写TIF函数,OK。（这个是成品）
49,以47为基础，按照读入的读出，ok
50,归结为函数后，调用，ok
51,用二维数组去看看，是否合适.ok
52,先找范围，对于以一个小的为参照物,遍历所在范围，然后通过该坐标，分别求出另外一个集合中的ID，从而能准确定位相减.OK
53,只保留差值，且把这些值均加上140,OK
54,加入opencv,读入cv::Mat,再输出数值，OK
55,开运算，输出大小，发现一样.输出tifok
57,tif转点云，需要校正下。OK
58,命令行格式,ok

59,PCL滤波,输入点云,输出还是点云
60,pcd和.las互换
61,pcl::HarrisKeypoint2D,读取图像,OK
62,读取点云,OK
63,输出点云的值,OK
64,用opencv进行harris
65,网上的点云配准,有bug
66,icp(未完)
67,ICP(小pcd)
68,书上的正态分布点云配准
69,从dem-2013和dem-2016各取出一部分配准,是可以运行不崩溃的,运行时间太长
70,变成narf距离图像进行配准.(未完)
71,深度图像进行,但是由于中心点在(0,0,0)所以只看到了30个点.
72,设定摄像机位置,求出点云的x,y,z的极值。然后再把摄像机放在X,Y的中心，z大概是zmin+distanceX,充分映射深度图，OK
73,输出这个深度图的值，发现有离群点，
74,根据深度图生成点云,发现有离群点.
75,点云粗配准和精细配准两步
76,修正了输入点云为空的bug
77,剩下了一致点对太少的问题.
78,更改API后，转换函数有值了。
79，fph的邻近点个数由250改为10之后，fph有值了
80，发现 原来为 fprintf(fp_cloud_PFH2, " <%f>, ", cloud_PFH2->at(i).descriptorSize);
	改为fprintf(fp_cloud_PFH2, " <%d>, ", cloud_PFH2->at(i).descriptorSize());
,ok.pfh有值。但是fp_correspondences和fp_cor_inliners_ptr全为0

81，
fprintf(fp_correspondences, "<%f,%f>", correspondences->at(i).index_match, correspondences->at(i).index_query);
fprintf(fp_cor_inliners_ptr, "<%f,%f>", cor_inliners_ptr->at(i).index_match, cor_inliners_ptr->at(i).index_query );
改为
fprintf(fp_correspondences, "<%d,%d,%f,%f>", correspondences->at(i).index_match, correspondences->at(i).index_query, correspondences->at(i).distance, correspondences->at(i).weight);
fprintf(fp_cor_inliners_ptr, "<%d,%d,%f,%f>", cor_inliners_ptr->at(i).index_match, cor_inliners_ptr->at(i).index_query, cor_inliners_ptr->at(i).distance, cor_inliners_ptr->at(i).weight);
OK,有值了。

82，用double epsilon_sac = 0.1; // 10cm，变换矩阵仍为单位矩阵
83，

  pcl::registration::TransformationEstimationSVD<Point, Point> trans_est;
  Eigen::Matrix4f transform_svd;
  trans_est.estimateRigidTransformation(cloud_input, cloud_target, correspondeces_sac, transform_svd);
直接对比两个点云,ok,转换矩阵不是单位向量了，并且接近于cloud_sampled2
84,在转换矩阵中，输入点云为描述子试试。果然更接近目标点云
85,icp迭代次数为20000次和200次进行比较下。没区别，说明很快就收敛了。粗配准和细配准后，差别不大 。说明icp没有搞好。

86，粗配准sac粗差时多试试内部点阈值，10的 -100次方到10的99次方，发现都是单位矩阵。
87，以85为基础，进行dem2013和2016的配准,相差比较大
88，先试关键点，Harris2D，不支持无序
89，滤波试试，votexgrid不用点对，只用sift过滤
91，以85为基础，进行调参，5个pfh近邻5个，更偏差。4个的街坊距离最短。
92，调整sift的几个参数。min_contrast = 0.15时最小
93，调整各参数,街坊距离242
94,判断点对是否正确,输出,发现有偏差
95,写10000个相同的点平移,看看点对是否一致。不一致。
看看同一点云10000个，是否一致，同一个倒是可以对准的
96,换xyz.pcd和xyz_translation_del_building.pcd试试.相差街坊距离27，源点云和目标点云街坊距离是280，对应点不是（0，0）。
97，将xyz.pcd换成平移后的点云，用以校准，看看是否对应点为（0，0），发现siftout第六个和第7个仍然不对。说明阈值有问题。如果两个用的都是siftOut1,
98，将siftout2的内容由sift1_out平移试下，看看是不是对应点对（0，0），发现也是差的太远了。
99，将normal复制下看看，发现基本很多都匹配了。所以说，得看看中心点在哪里。normal可以认为点云重心在中心点，这里的法线向量是局部坐标系的概念，OK
100,同normal时，将siftout2用计算得到的,sift无重复点，街坊距离11；有重复点时变换矩阵离1就差比较大了。
101,将normal都写到点云中心。ok,太精准了，99.8%以上。搞正确normal后再试试sift是否过滤重复值，不过滤相差太远了。
102，用两个文件试下，不用一个点云平移的方式了。是98.6%以上
103，加上个差值点云，看看目标点云与配准点云的差别 ,很小
104，以101为基础，x，y,z平移1000，其余不变。根据对应点对来核实计算矩阵。（配准相当精确，误差x,y,z最多在5以内）。
106，用dem2013.pcd和dem2016.pcd试试,采样100万点,相差太远了.
107,以104为基础,进行调整,可否用sac剔除杂点的方式.要在误差1以内. epsilon_sac = 1.0;，更提高了精确度99.92%以上，ok
108,epsilon_sac = 2.0试下，和epsilon_sac =1相同；epsilon_sac =10时，一样，因为内点没有过滤。还是那些数值。从源码上看,默认为0.05
两个法线向量是有差距的,用float代替double，向量基本一致了，但是最终精度降低。将sift也用float，也降低了。如果一切float均用double,
109,法线向量setRadiusSearch(searchRadius);要用setKSearch（）替代，因为点云尺度不同，要根据周围个数，而不是半径，k=4比k=20法线更接近。
k=10时，匹配度达到99.95%，k=15时，匹配度达到99.99%以上,但法向量偏离大，
110,提取两个点云的深度图,OK
111,提取深度图边界.生成narfcloud,supportsize有问题
112,计算深度图长宽,长362,宽16,supportSize = 1.0是有问题的，有些小
113，将距离再近些，争取尽可能大的深度图，设为原距离的1/5，则为（362，56）；1/50，则为（361，110），
114，supportSize_NarfKeypoint设定为1会崩溃，0.1,视点转到原点，不崩溃了，但是只有（4，4），点为0，放在中点崩溃
115，深度图暂时不搞，以109为基础，试试dem2013和2016在pfhestimation，差的太远
116，用opencv试下，dem2013和dem2016,配置完后,没问题了,可以粗配准了
117,按地理坐标匹配，1000*1000，先计算出一个图的std::vector<>,根据坐标，计算出另外一幅图相应的位置（i,j)。计算出相应位置的值。at(i,j)=灰度值。
118,对匹配点对剔除杂点,去前一半,还是有交叉点,不准.
119,用同一个平移试下,就是第一个用(2000,2000)开头，第二个用(2200,2200)，平移是没问题的。
120，在文件里输出相应的坐标
121,读取8bit的.tif,粗配准很差。
122,差的比较多了。
123，用全图匹配下。意义不大，不是包含的关系 。
124，用2000*100试下,发现坐标一样,匹配不准
125,从.tif里面，读取代码。获得一个,如果diffX在(-50,50)和diffy在（-10，10）之间，则输出 

用欧式距离BruteForce<L2<float>>，试下float

从float转换到u8时相对的值，

2013和2016分块配准.每10万10万的进行（可以先放缩，缩小距离）;或者直接用深度图找narf，因为像素分辨率太大了 。


变换矩阵的对角线分别是,目标与源点云的相似度 。位移为0，x+detaX/x; y+deltaY/y,z+deltaZ/z
normals,siftout最小个数，
有42个点的缺少.sift_out还有冗余点,应该去掉冗余点.或者再调整siftout参数。
问题关键就是平移后旋转和旋转后平移的区别。

变换矩阵要接近于单位矩阵，关键点不要重复。因为这个会影响特征描述子，进而影响变换矩阵。


换换Narf特征点
siftout数量不一致，是否该滤波？一致？
或者siftout点云的索引？
能不能用向量估计?是
法线向量看看是否一致.

可以把dem2013和2016相互对应的点.输出,看看是否类似.
点加多些,比如100万个点,是否更精确些.
调参，把这几个参数都调整下。从pfh的近邻10个开始调整。

深度图像narf关键点试下

现在的问题集中在粗配准上了 。看看pcl/registration/文件夹里的各种estimation

各种关键点，各种描述子，各种粗配准


如何滤波，不一定只有一种方法。

去除杂点并不说明配准。因此去掉杂点后，还要再粗配准或者粗配准后去杂点。然后再细配准。

reject的输入两个云大小是不是应该一样大小？修正下试试
getRemainingCorrespondences (const pcl::Correspondences& original_correspondences, 
 
                                    pcl::Correspondences& remaining_correspondences);

可以考虑把correnspondence更改下。

用
粗配准过程

用xyz,xxyz_translation_del_building.pcd进行测试.


提交时，算法结束后
