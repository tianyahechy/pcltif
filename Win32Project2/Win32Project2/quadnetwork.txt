1,查找每个点是否在三角形,再插值,ok
2，将每个三角形的内接矩形中有哪些栅格在里面，则只插值在三角形里面的栅格点，初始化时全为0
，这样每个栅格点只与一个三角形判断，而不是一个区域的三角形判断，应该能够大大缩短时间。结果157秒，因为以前的各种分块已经基本上优化到每个点和一个三角形过滤了。
3，将点是否在三角形上的算法改变下。将以往的叉乘改为正负区，速度没有提升，算法有误。
4，将比较的栅格缩小到三角形的外接矩形这么大。2万点78秒，4万点139秒，8万点408秒，16万点
5，在
    // Insert vertices of the polygon as our initial point set.
//点和顶点句柄关联，如果顶点句柄和三角形能关联，就好了
   
 for(int i = 0; i < number_of_vertices; ++i) 
	vertex_handle[i] = cdt.insert(vertices[i]);
ok,但是图像反了.

2万点,读取点云63秒,其余不计,共63秒
4万点,读取点云61秒,插值1秒,其余不计,共62秒
8万点，读取点云63秒,三角化1秒,其余不计,共64秒
16万点，读取点云60秒,三角化2秒,插值1秒，其余不计,共63秒
32万点，读取点云63秒,三角化3秒，找三角形高度1秒,插值1秒，其余不计,共68秒
100万点，读取点云61秒,三角化9秒，找三角形高度1秒,插值3秒，其余不计,共74秒
200万点，读取点云62秒,三角化16秒，找三角形高度3秒,插值5秒，其余不计,共86秒
400万点，读取点云61秒,三角化25秒，找三角形高度6秒,插值12秒，其余不计,共104秒
900万点，读取点云62秒,三角化58秒，找三角形高度16秒,插值104秒，写入文件4秒,共244秒
2400万点 读取点云307秒,
考虑到缓存，要不要把这些值按照三角形的外接矩形逐一写入tif,只写这些值。

6,上下颠倒,ok
7,去掉-9999这个值,OK

8,规整代码,读如点云名称,输出栅格集,ok


输入点云和像素分辨率,求出栅格集合

出现杂点(577,882)这个点灰度值是134.514282,查找该点所在的三角形,并输出
可以将上半部分用白色,下班部分黑色,导出来看看是不是这个东西.或者一个点,一条边去写入


根据坐标将这些点云放入相应的小格子里，栅格值就是四个邻域的点云的灰度值加权平均值。






也就是说，点和三角形相查找比较的方式，基本上到头了。或者改进点是否在三角形上的算法要么就切割点云，形成小的.tif文件后拼接。


计算多了好几步，查找速度快76秒


可能坐标系不同，因此除法得到的行列数不同于计算出来的坐标。

